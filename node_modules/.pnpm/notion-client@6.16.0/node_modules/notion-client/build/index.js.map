{"version":3,"sources":["../src/notion-api.ts"],"sourcesContent":["// import { promises as fs } from 'fs'\nimport * as notion from 'notion-types'\nimport got, { OptionsOfJSONResponseBody } from 'got'\nimport {\n  getBlockCollectionId,\n  getPageContentBlockIds,\n  parsePageId,\n  uuidToId\n} from 'notion-utils'\nimport pMap from 'p-map'\n\nimport * as types from './types'\n\n/**\n * Main Notion API client.\n */\nexport class NotionAPI {\n  private readonly _apiBaseUrl: string\n  private readonly _authToken?: string\n  private readonly _activeUser?: string\n  private readonly _userTimeZone: string\n\n  constructor({\n    apiBaseUrl = 'https://www.notion.so/api/v3',\n    authToken,\n    activeUser,\n    userTimeZone = 'America/New_York'\n  }: {\n    apiBaseUrl?: string\n    authToken?: string\n    userLocale?: string\n    userTimeZone?: string\n    activeUser?: string\n  } = {}) {\n    this._apiBaseUrl = apiBaseUrl\n    this._authToken = authToken\n    this._activeUser = activeUser\n    this._userTimeZone = userTimeZone\n  }\n\n  public async getPage(\n    pageId: string,\n    {\n      concurrency = 3,\n      fetchMissingBlocks = true,\n      fetchCollections = true,\n      signFileUrls = true,\n      chunkLimit = 100,\n      chunkNumber = 0,\n      gotOptions\n    }: {\n      concurrency?: number\n      fetchMissingBlocks?: boolean\n      fetchCollections?: boolean\n      signFileUrls?: boolean\n      chunkLimit?: number\n      chunkNumber?: number\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ): Promise<notion.ExtendedRecordMap> {\n    const page = await this.getPageRaw(pageId, {\n      chunkLimit,\n      chunkNumber,\n      gotOptions\n    })\n    const recordMap = page?.recordMap as notion.ExtendedRecordMap\n\n    if (!recordMap?.block) {\n      throw new Error(`Notion page not found \"${uuidToId(pageId)}\"`)\n    }\n\n    // ensure that all top-level maps exist\n    recordMap.collection = recordMap.collection ?? {}\n    recordMap.collection_view = recordMap.collection_view ?? {}\n    recordMap.notion_user = recordMap.notion_user ?? {}\n\n    // additional mappings added for convenience\n    // note: these are not native notion objects\n    recordMap.collection_query = {}\n    recordMap.signed_urls = {}\n\n    if (fetchMissingBlocks) {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // fetch any missing content blocks\n        const pendingBlockIds = getPageContentBlockIds(recordMap).filter(\n          (id) => !recordMap.block[id]\n        )\n\n        if (!pendingBlockIds.length) {\n          break\n        }\n\n        const newBlocks = await this.getBlocks(\n          pendingBlockIds,\n          gotOptions\n        ).then((res) => res.recordMap.block)\n\n        recordMap.block = { ...recordMap.block, ...newBlocks }\n      }\n    }\n\n    const contentBlockIds = getPageContentBlockIds(recordMap)\n\n    // Optionally fetch all data for embedded collections and their associated views.\n    // NOTE: We're eagerly fetching *all* data for each collection and all of its views.\n    // This is really convenient in order to ensure that all data needed for a given\n    // Notion page is readily available for use cases involving server-side rendering\n    // and edge caching.\n    if (fetchCollections) {\n      const allCollectionInstances: Array<{\n        collectionId: string\n        collectionViewId: string\n      }> = contentBlockIds.flatMap((blockId) => {\n        const block = recordMap.block[blockId].value\n        const collectionId =\n          block &&\n          (block.type === 'collection_view' ||\n            block.type === 'collection_view_page') &&\n          getBlockCollectionId(block, recordMap)\n\n        if (collectionId) {\n          return block.view_ids?.map((collectionViewId) => ({\n            collectionId,\n            collectionViewId\n          }))\n        } else {\n          return []\n        }\n      })\n\n      // fetch data for all collection view instances\n      await pMap(\n        allCollectionInstances,\n        async (collectionInstance) => {\n          const { collectionId, collectionViewId } = collectionInstance\n          const collectionView =\n            recordMap.collection_view[collectionViewId]?.value\n\n          try {\n            const collectionData = await this.getCollectionData(\n              collectionId,\n              collectionViewId,\n              collectionView,\n              {\n                gotOptions\n              }\n            )\n\n            // await fs.writeFile(\n            //   `${collectionId}-${collectionViewId}.json`,\n            //   JSON.stringify(collectionData.result, null, 2)\n            // )\n\n            recordMap.block = {\n              ...recordMap.block,\n              ...collectionData.recordMap.block\n            }\n\n            recordMap.collection = {\n              ...recordMap.collection,\n              ...collectionData.recordMap.collection\n            }\n\n            recordMap.collection_view = {\n              ...recordMap.collection_view,\n              ...collectionData.recordMap.collection_view\n            }\n\n            recordMap.notion_user = {\n              ...recordMap.notion_user,\n              ...collectionData.recordMap.notion_user\n            }\n\n            recordMap.collection_query![collectionId] = {\n              ...recordMap.collection_query![collectionId],\n              [collectionViewId]: (collectionData.result as any)?.reducerResults\n            }\n          } catch (err) {\n            // It's possible for public pages to link to private collections, in which case\n            // Notion returns a 400 error\n            console.warn('NotionAPI collectionQuery error', pageId, err.message)\n            console.error(err)\n          }\n        },\n        {\n          concurrency\n        }\n      )\n    }\n\n    // Optionally fetch signed URLs for any embedded files.\n    // NOTE: Similar to collection data, we default to eagerly fetching signed URL info\n    // because it is preferable for many use cases as opposed to making these API calls\n    // lazily from the client-side.\n    if (signFileUrls) {\n      await this.addSignedUrls({ recordMap, contentBlockIds, gotOptions })\n    }\n\n    return recordMap\n  }\n\n  public async addSignedUrls({\n    recordMap,\n    contentBlockIds,\n    gotOptions = {}\n  }: {\n    recordMap: notion.ExtendedRecordMap\n    contentBlockIds?: string[]\n    gotOptions?: OptionsOfJSONResponseBody\n  }) {\n    recordMap.signed_urls = {}\n\n    if (!contentBlockIds) {\n      contentBlockIds = getPageContentBlockIds(recordMap)\n    }\n\n    const allFileInstances = contentBlockIds.flatMap((blockId) => {\n      const block = recordMap.block[blockId]?.value\n\n      if (\n        block &&\n        (block.type === 'pdf' ||\n          block.type === 'audio' ||\n          (block.type === 'image' && block.file_ids?.length) ||\n          block.type === 'video' ||\n          block.type === 'file' ||\n          block.type === 'page')\n      ) {\n        const source =\n          block.type === 'page'\n            ? block.format?.page_cover\n            : block.properties?.source?.[0]?.[0]\n        // console.log(block, source)\n\n        if (source) {\n          if (!source.includes('secure.notion-static.com')) {\n            return []\n          }\n\n          return {\n            permissionRecord: {\n              table: 'block',\n              id: block.id\n            },\n            url: source\n          }\n        }\n      }\n\n      return []\n    })\n\n    if (allFileInstances.length > 0) {\n      try {\n        const { signedUrls } = await this.getSignedFileUrls(\n          allFileInstances,\n          gotOptions\n        )\n\n        if (signedUrls.length === allFileInstances.length) {\n          for (let i = 0; i < allFileInstances.length; ++i) {\n            const file = allFileInstances[i]\n            const signedUrl = signedUrls[i]\n\n            recordMap.signed_urls[file.permissionRecord.id] = signedUrl\n          }\n        }\n      } catch (err) {\n        console.warn('NotionAPI getSignedfileUrls error', err)\n      }\n    }\n  }\n\n  public async getPageRaw(\n    pageId: string,\n    {\n      gotOptions,\n      chunkLimit = 100,\n      chunkNumber = 0\n    }: {\n      chunkLimit?: number\n      chunkNumber?: number\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ) {\n    const parsedPageId = parsePageId(pageId)\n\n    if (!parsedPageId) {\n      throw new Error(`invalid notion pageId \"${pageId}\"`)\n    }\n\n    const body = {\n      pageId: parsedPageId,\n      limit: chunkLimit,\n      chunkNumber: chunkNumber,\n      cursor: { stack: [] },\n      verticalColumns: false\n    }\n\n    return this.fetch<notion.PageChunk>({\n      endpoint: 'loadPageChunk',\n      body,\n      gotOptions\n    })\n  }\n\n  public async getCollectionData(\n    collectionId: string,\n    collectionViewId: string,\n    collectionView: any,\n    {\n      limit = 9999,\n      searchQuery = '',\n      userTimeZone = this._userTimeZone,\n      loadContentCover = true,\n      gotOptions\n    }: {\n      type?: notion.CollectionViewType\n      limit?: number\n      searchQuery?: string\n      userTimeZone?: string\n      userLocale?: string\n      loadContentCover?: boolean\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ) {\n    const type = collectionView?.type\n    const isBoardType = type === 'board'\n    const groupBy = isBoardType\n      ? collectionView?.format?.board_columns_by\n      : collectionView?.format?.collection_group_by\n\n    let filters = []\n    if (collectionView?.format?.property_filters) {\n      filters = collectionView.format?.property_filters.map((filterObj) => {\n        //get the inner filter\n        return {\n          filter: filterObj?.filter?.filter,\n          property: filterObj?.filter?.property\n        }\n      })\n    }\n\n    //Fixes formula filters from not working\n    if (collectionView?.query2?.filter?.filters) {\n      filters.push(...collectionView.query2.filter.filters)\n    }\n\n    let loader: any = {\n      type: 'reducer',\n      reducers: {\n        collection_group_results: {\n          type: 'results',\n          limit,\n          loadContentCover\n        }\n      },\n      sort: [],\n      ...collectionView?.query2,\n      filter: {\n        filters: filters,\n        operator: 'and'\n      },\n      searchQuery,\n      userTimeZone\n    }\n\n    if (groupBy) {\n      const groups =\n        collectionView?.format?.board_columns ||\n        collectionView?.format?.collection_groups ||\n        []\n      const iterators = [isBoardType ? 'board' : 'group_aggregation', 'results']\n      const operators = {\n        checkbox: 'checkbox_is',\n        url: 'string_starts_with',\n        text: 'string_starts_with',\n        select: 'enum_is',\n        multi_select: 'enum_contains',\n        created_time: 'date_is_within',\n        ['undefined']: 'is_empty'\n      }\n\n      const reducersQuery = {}\n      for (const group of groups) {\n        const {\n          property,\n          value: { value, type }\n        } = group\n\n        for (const iterator of iterators) {\n          const iteratorProps =\n            iterator === 'results'\n              ? {\n                  type: iterator,\n                  limit\n                }\n              : {\n                  type: 'aggregation',\n                  aggregation: {\n                    aggregator: 'count'\n                  }\n                }\n\n          const isUncategorizedValue = typeof value === 'undefined'\n          const isDateValue = value?.range\n          // TODO: review dates reducers\n          const queryLabel = isUncategorizedValue\n            ? 'uncategorized'\n            : isDateValue\n            ? value.range?.start_date || value.range?.end_date\n            : value?.value || value\n\n          const queryValue =\n            !isUncategorizedValue && (isDateValue || value?.value || value)\n\n          reducersQuery[`${iterator}:${type}:${queryLabel}`] = {\n            ...iteratorProps,\n            filter: {\n              operator: 'and',\n              filters: [\n                {\n                  property,\n                  filter: {\n                    operator: !isUncategorizedValue\n                      ? operators[type]\n                      : 'is_empty',\n                    ...(!isUncategorizedValue && {\n                      value: {\n                        type: 'exact',\n                        value: queryValue\n                      }\n                    })\n                  }\n                }\n              ]\n            }\n          }\n        }\n      }\n\n      const reducerLabel = isBoardType ? 'board_columns' : `${type}_groups`\n      loader = {\n        type: 'reducer',\n        reducers: {\n          [reducerLabel]: {\n            type: 'groups',\n            groupBy,\n            ...(collectionView?.query2?.filter && {\n              filter: collectionView?.query2?.filter\n            }),\n            groupSortPreference: groups.map((group) => group?.value),\n            limit\n          },\n          ...reducersQuery\n        },\n        ...collectionView?.query2,\n        searchQuery,\n        userTimeZone,\n        //TODO: add filters here\n        filter: {\n          filters: filters,\n          operator: 'and'\n        }\n      }\n    }\n\n    // if (isBoardType) {\n    //   console.log(\n    //     JSON.stringify(\n    //       {\n    //         collectionId,\n    //         collectionViewId,\n    //         loader,\n    //         groupBy: groupBy || 'NONE',\n    //         collectionViewQuery: collectionView.query2 || 'NONE'\n    //       },\n    //       null,\n    //       2\n    //     )\n    //   )\n    // }\n\n    return this.fetch<notion.CollectionInstance>({\n      endpoint: 'queryCollection',\n      body: {\n        collection: {\n          id: collectionId\n        },\n        collectionView: {\n          id: collectionViewId\n        },\n        loader\n      },\n      gotOptions\n    })\n  }\n\n  public async getUsers(\n    userIds: string[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<notion.RecordValues<notion.User>>({\n      endpoint: 'getRecordValues',\n      body: {\n        requests: userIds.map((id) => ({ id, table: 'notion_user' }))\n      },\n      gotOptions\n    })\n  }\n\n  public async getBlocks(\n    blockIds: string[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<notion.PageChunk>({\n      endpoint: 'syncRecordValues',\n      body: {\n        requests: blockIds.map((blockId) => ({\n          // TODO: when to use table 'space' vs 'block'?\n          table: 'block',\n          id: blockId,\n          version: -1\n        }))\n      },\n      gotOptions\n    })\n  }\n\n  public async getSignedFileUrls(\n    urls: types.SignedUrlRequest[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<types.SignedUrlResponse>({\n      endpoint: 'getSignedFileUrls',\n      body: {\n        urls\n      },\n      gotOptions\n    })\n  }\n\n  public async search(\n    params: notion.SearchParams,\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    const body = {\n      type: 'BlocksInAncestor',\n      source: 'quick_find_public',\n      ancestorId: parsePageId(params.ancestorId),\n      sort: 'Relevance',\n      limit: params.limit || 20,\n      query: params.query,\n      filters: {\n        isDeletedOnly: false,\n        isNavigableOnly: false,\n        excludeTemplates: true,\n        requireEditPermissions: false,\n        ancestors: [],\n        createdBy: [],\n        editedBy: [],\n        lastEditedTime: {},\n        createdTime: {},\n        ...params.filters\n      }\n    }\n\n    return this.fetch<notion.SearchResults>({\n      endpoint: 'search',\n      body,\n      gotOptions\n    })\n  }\n\n  public async fetch<T>({\n    endpoint,\n    body,\n    gotOptions,\n    headers: clientHeaders\n  }: {\n    endpoint: string\n    body: object\n    gotOptions?: OptionsOfJSONResponseBody\n    headers?: any\n  }): Promise<T> {\n    const headers: any = {\n      ...clientHeaders,\n      ...gotOptions?.headers,\n      'Content-Type': 'application/json'\n    }\n\n    if (this._authToken) {\n      headers.cookie = `token_v2=${this._authToken}`\n    }\n\n    if (this._activeUser) {\n      headers['x-notion-active-user-header'] = this._activeUser\n    }\n\n    const url = `${this._apiBaseUrl}/${endpoint}`\n\n    return got\n      .post(url, {\n        ...gotOptions,\n        json: body,\n        headers\n      })\n      .json()\n\n    // return fetch(url, {\n    //   method: 'post',\n    //   body: JSON.stringify(body),\n    //   headers\n    // }).then((res) => {\n    //   console.log(endpoint, res)\n    //   return res.json()\n    // })\n  }\n}\n"],"mappings":"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","names":["got","getBlockCollectionId","getPageContentBlockIds","parsePageId","uuidToId","pMap","NotionAPI","apiBaseUrl","authToken","activeUser","userTimeZone","pageId","concurrency","fetchMissingBlocks","fetchCollections","signFileUrls","chunkLimit","chunkNumber","gotOptions","page","recordMap","pendingBlockIds","id","newBlocks","res","contentBlockIds","allCollectionInstances","blockId","_a","block","collectionId","collectionViewId","collectionInstance","_b","collectionView","collectionData","err","allFileInstances","_c","_d","_e","_f","source","signedUrls","i","file","signedUrl","parsedPageId","body","limit","searchQuery","loadContentCover","_g","_h","_i","_j","_k","_l","type","isBoardType","groupBy","filters","filterObj","loader","groups","iterators","operators","reducersQuery","group","property","value","iterator","iteratorProps","isUncategorizedValue","isDateValue","queryLabel","queryValue","reducerLabel","userIds","blockIds","urls","params","endpoint","clientHeaders","headers","url"]}