var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { logger } from '../../utils/logger';
import { isBoolean, isNullish, isObject, isUndefined } from '../../utils/type-utils';
import { WEB_VITALS_ENABLED_SERVER_SIDE } from '../../constants';
import { assignableWindow, window } from '../../utils/globals';
import Config from '../../config';
export var FLUSH_TO_CAPTURE_TIMEOUT_MILLISECONDS = 8000;
var LOGGER_PREFIX = '[Web Vitals]';
var WebVitalsAutocapture = /** @class */ (function () {
    function WebVitalsAutocapture(instance) {
        var _this = this;
        var _a;
        this.instance = instance;
        this._enabledServerSide = false;
        this._initialized = false;
        this.buffer = { url: undefined, metrics: [], firstMetricTimestamp: undefined };
        this._flushToCapture = function () {
            clearTimeout(_this._delayedFlushTimer);
            if (_this.buffer.metrics.length === 0) {
                return;
            }
            _this.instance.capture('$web_vitals', _this.buffer.metrics.reduce(function (acc, metric) {
                var _a;
                return (__assign(__assign({}, acc), (_a = {}, _a["$web_vitals_".concat(metric.name, "_event")] = __assign({}, metric), _a["$web_vitals_".concat(metric.name, "_value")] = metric.value, _a)));
            }, {}));
            _this.buffer = { url: undefined, metrics: [], firstMetricTimestamp: undefined };
        };
        this._addToBuffer = function (metric) {
            var _a;
            var sessionIds = (_a = _this.instance.sessionManager) === null || _a === void 0 ? void 0 : _a.checkAndGetSessionAndWindowId(true);
            if (isUndefined(sessionIds)) {
                logger.error(LOGGER_PREFIX + 'Could not read session ID. Dropping metrics!');
                return;
            }
            _this.buffer = _this.buffer || {};
            var $currentUrl = _this._currentURL();
            if (isUndefined($currentUrl)) {
                return;
            }
            if (isNullish(metric === null || metric === void 0 ? void 0 : metric.name) || isNullish(metric === null || metric === void 0 ? void 0 : metric.value)) {
                logger.error(LOGGER_PREFIX + 'Invalid metric received', metric);
                return;
            }
            var urlHasChanged = _this.buffer.url !== $currentUrl;
            if (urlHasChanged) {
                // we need to send what we have
                _this._flushToCapture();
                // poor performance is >4s, we wait twice that time to send
                // this is in case we haven't received all metrics
                // we'll at least gather some
                _this._delayedFlushTimer = setTimeout(_this._flushToCapture, FLUSH_TO_CAPTURE_TIMEOUT_MILLISECONDS);
            }
            if (isUndefined(_this.buffer.url)) {
                _this.buffer.url = $currentUrl;
            }
            _this.buffer.firstMetricTimestamp = isUndefined(_this.buffer.firstMetricTimestamp)
                ? Date.now()
                : _this.buffer.firstMetricTimestamp;
            _this.buffer.metrics.push(__assign(__assign({}, metric), { $current_url: $currentUrl, $session_id: sessionIds.sessionId, $window_id: sessionIds.windowId, timestamp: Date.now() }));
            if (_this.buffer.metrics.length === 4) {
                // we have all 4 metrics
                _this._flushToCapture();
            }
        };
        this._startCapturing = function () {
            var _a = assignableWindow.postHogWebVitalsCallbacks, onLCP = _a.onLCP, onCLS = _a.onCLS, onFCP = _a.onFCP, onINP = _a.onINP;
            // register performance observers
            onLCP(_this._addToBuffer);
            onCLS(_this._addToBuffer);
            onFCP(_this._addToBuffer);
            onINP(_this._addToBuffer);
            _this._initialized = true;
        };
        this._enabledServerSide = !!((_a = this.instance.persistence) === null || _a === void 0 ? void 0 : _a.props[WEB_VITALS_ENABLED_SERVER_SIDE]);
        this.startIfEnabled();
    }
    Object.defineProperty(WebVitalsAutocapture.prototype, "isEnabled", {
        get: function () {
            var clientConfig = isObject(this.instance.config.capture_performance)
                ? this.instance.config.capture_performance.web_vitals
                : undefined;
            return isBoolean(clientConfig) ? clientConfig : this._enabledServerSide;
        },
        enumerable: false,
        configurable: true
    });
    WebVitalsAutocapture.prototype.startIfEnabled = function () {
        if (this.isEnabled && !this._initialized) {
            logger.info(LOGGER_PREFIX + ' enabled, starting...');
            this.loadScript(this._startCapturing);
        }
    };
    WebVitalsAutocapture.prototype.afterDecideResponse = function (response) {
        var _a;
        var webVitalsOptIn = isObject(response.capturePerformance) && !!response.capturePerformance.web_vitals;
        if (this.instance.persistence) {
            this.instance.persistence.register((_a = {},
                _a[WEB_VITALS_ENABLED_SERVER_SIDE] = webVitalsOptIn,
                _a));
        }
        // store this in-memory in case persistence is disabled
        this._enabledServerSide = webVitalsOptIn;
        this.startIfEnabled();
    };
    WebVitalsAutocapture.prototype.loadScript = function (cb) {
        if (window.postHogWebVitalsCallbacks) {
            // already loaded
            cb();
        }
        this.instance.requestRouter.loadScript(this.instance.requestRouter.endpointFor('assets', "/static/web-vitals.js?v=".concat(Config.LIB_VERSION)), function (err) {
            if (err) {
                logger.error(LOGGER_PREFIX + ' failed to load script', err);
            }
            cb();
        });
    };
    WebVitalsAutocapture.prototype._currentURL = function () {
        // TODO you should be able to mask the URL here
        var href = window ? window.location.href : undefined;
        if (!href) {
            logger.error(LOGGER_PREFIX + 'Could not determine current URL');
        }
        return href;
    };
    return WebVitalsAutocapture;
}());
export { WebVitalsAutocapture };
//# sourceMappingURL=index.js.map