{"version":3,"file":"recorder.js","sourceRoot":"","sources":["../../../src/entrypoints/recorder.ts"],"names":[],"mappings":"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","sourcesContent":["import { version } from 'rrweb/package.json'\n\n// Same as loader-globals.ts except includes rrweb2 scripts.\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport rrwebRecord from 'rrweb/es/rrweb/packages/rrweb/src/record'\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport { getRecordConsolePlugin } from 'rrweb/es/rrweb/packages/rrweb/src/plugins/console/record'\n\n// rrweb/network@1 code starts\n// most of what is below here will be removed when rrweb release their code for this\n// see https://github.com/rrweb-io/rrweb/pull/1105\n/// <reference lib=\"dom\" />\n// NB adopted from https://github.com/rrweb-io/rrweb/pull/1105 which looks like it will be accepted into rrweb\n// however, in the PR, it throws when the performance observer data is not available\n// and assumes it is running in a browser with the Request API (i.e. not IE11)\n// copying here so that we can use it before rrweb adopt it\nimport type { IWindow, listenerHandler, RecordPlugin } from '@rrweb/types'\nimport { CapturedNetworkRequest, Headers, InitiatorType, NetworkRecordOptions } from '../types'\nimport { isArray, isBoolean, isDocument, isFormData, isNull, isNullish, isObject, isString } from '../utils/type-utils'\nimport { logger } from '../utils/logger'\nimport { window } from '../utils/globals'\nimport { defaultNetworkOptions } from '../extensions/replay/config'\nimport { formDataToQuery } from '../utils/request-utils'\nimport { patch } from '../extensions/replay/rrweb-plugins/patch'\nimport { isHostOnDenyList } from '../extensions/replay/external/denylist'\n\nexport type NetworkData = {\n    requests: CapturedNetworkRequest[]\n    isInitial?: boolean\n}\n\ntype networkCallback = (data: NetworkData) => void\n\nconst isNavigationTiming = (entry: PerformanceEntry): entry is PerformanceNavigationTiming =>\n    entry.entryType === 'navigation'\nconst isResourceTiming = (entry: PerformanceEntry): entry is PerformanceResourceTiming => entry.entryType === 'resource'\n\ntype ObservedPerformanceEntry = (PerformanceNavigationTiming | PerformanceResourceTiming) & {\n    responseStatus?: number\n}\n\nexport function findLast<T>(array: Array<T>, predicate: (value: T) => boolean): T | undefined {\n    const length = array.length\n    for (let i = length - 1; i >= 0; i -= 1) {\n        if (predicate(array[i])) {\n            return array[i]\n        }\n    }\n    return undefined\n}\n\nfunction initPerformanceObserver(cb: networkCallback, win: IWindow, options: Required<NetworkRecordOptions>) {\n    // if we are only observing timings then we could have a single observer for all types, with buffer true,\n    // but we are going to filter by initiatorType _if we are wrapping fetch and xhr as the wrapped functions\n    // will deal with those.\n    // so we have a block which captures requests from before fetch/xhr is wrapped\n    // these are marked `isInitial` so playback can display them differently if needed\n    // they will never have method/status/headers/body because they are pre-wrapping that provides that\n    if (options.recordInitialRequests) {\n        const initialPerformanceEntries = win.performance\n            .getEntries()\n            .filter(\n                (entry): entry is ObservedPerformanceEntry =>\n                    isNavigationTiming(entry) ||\n                    (isResourceTiming(entry) && options.initiatorTypes.includes(entry.initiatorType as InitiatorType))\n            )\n        cb({\n            requests: initialPerformanceEntries.flatMap((entry) =>\n                prepareRequest(entry, undefined, undefined, {}, true)\n            ),\n            isInitial: true,\n        })\n    }\n    const observer = new win.PerformanceObserver((entries) => {\n        // if recordBody or recordHeaders is true then we don't want to record fetch or xhr here\n        // as the wrapped functions will do that. Otherwise, this filter becomes a noop\n        // because we do want to record them here\n        const wrappedInitiatorFilter = (entry: ObservedPerformanceEntry) =>\n            options.recordBody || options.recordHeaders\n                ? entry.initiatorType !== 'xmlhttprequest' && entry.initiatorType !== 'fetch'\n                : true\n\n        const performanceEntries = entries.getEntries().filter(\n            (entry): entry is ObservedPerformanceEntry =>\n                isNavigationTiming(entry) ||\n                (isResourceTiming(entry) &&\n                    options.initiatorTypes.includes(entry.initiatorType as InitiatorType) &&\n                    // TODO if we are _only_ capturing timing we don't want to filter initiator here\n                    wrappedInitiatorFilter(entry))\n        )\n\n        cb({\n            requests: performanceEntries.flatMap((entry) => prepareRequest(entry, undefined, undefined, {})),\n        })\n    })\n    // compat checked earlier\n    // eslint-disable-next-line compat/compat\n    const entryTypes = PerformanceObserver.supportedEntryTypes.filter((x) =>\n        options.performanceEntryTypeToObserve.includes(x)\n    )\n    // initial records are gathered above, so we don't need to observe and buffer each type separately\n    observer.observe({ entryTypes })\n    return () => {\n        observer.disconnect()\n    }\n}\n\nfunction shouldRecordHeaders(type: 'request' | 'response', recordHeaders: NetworkRecordOptions['recordHeaders']) {\n    return !!recordHeaders && (isBoolean(recordHeaders) || recordHeaders[type])\n}\n\nfunction shouldRecordBody({\n    type,\n    recordBody,\n    headers,\n}: {\n    type: 'request' | 'response'\n    recordBody: NetworkRecordOptions['recordBody']\n    headers: Headers\n    url: string | URL | RequestInfo\n}) {\n    function matchesContentType(contentTypes: string[]) {\n        const contentTypeHeader = Object.keys(headers).find((key) => key.toLowerCase() === 'content-type')\n        const contentType = contentTypeHeader && headers[contentTypeHeader]\n        return contentTypes.some((ct) => contentType?.includes(ct))\n    }\n\n    if (!recordBody) return false\n    if (isBoolean(recordBody)) return true\n    if (isArray(recordBody)) return matchesContentType(recordBody)\n    const recordBodyType = recordBody[type]\n    if (isBoolean(recordBodyType)) return recordBodyType\n    return matchesContentType(recordBodyType)\n}\n\nasync function getRequestPerformanceEntry(\n    win: IWindow,\n    initiatorType: string,\n    url: string,\n    after?: number,\n    before?: number,\n    attempt = 0\n): Promise<PerformanceResourceTiming | null> {\n    if (attempt > 10) {\n        logger.warn('Failed to get performance entry for request', { url, initiatorType })\n        return null\n    }\n    const urlPerformanceEntries = win.performance.getEntriesByName(url) as PerformanceResourceTiming[]\n    const performanceEntry = findLast(\n        urlPerformanceEntries,\n        (entry) =>\n            isResourceTiming(entry) &&\n            entry.initiatorType === initiatorType &&\n            (!after || entry.startTime >= after) &&\n            (!before || entry.startTime <= before)\n    )\n    if (!performanceEntry) {\n        await new Promise((resolve) => setTimeout(resolve, 50 * attempt))\n        return getRequestPerformanceEntry(win, initiatorType, url, after, before, attempt + 1)\n    }\n    return performanceEntry\n}\n\n/**\n * According to MDN https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/response\n * xhr response is typed as any but can be an ArrayBuffer, a Blob, a Document, a JavaScript object,\n * or a string, depending on the value of XMLHttpRequest.responseType, that contains the response entity body.\n *\n * XHR request body is Document | XMLHttpRequestBodyInit | null | undefined\n */\nfunction _tryReadXHRBody({\n    body,\n    options,\n    url,\n}: {\n    body: Document | XMLHttpRequestBodyInit | any | null | undefined\n    options: NetworkRecordOptions\n    url: string | URL | RequestInfo\n}): string | null {\n    if (isNullish(body)) {\n        return null\n    }\n\n    const { hostname, isHostDenied } = isHostOnDenyList(url, options)\n    if (isHostDenied) {\n        return hostname + ' is in deny list'\n    }\n\n    if (isString(body)) {\n        return body\n    }\n\n    if (isDocument(body)) {\n        return body.textContent\n    }\n\n    if (isFormData(body)) {\n        return formDataToQuery(body)\n    }\n\n    if (isObject(body)) {\n        try {\n            return JSON.stringify(body)\n        } catch (e) {\n            return '[SessionReplay] Failed to stringify response object'\n        }\n    }\n\n    return '[SessionReplay] Cannot read body of type ' + toString.call(body)\n}\n\nfunction initXhrObserver(cb: networkCallback, win: IWindow, options: Required<NetworkRecordOptions>): listenerHandler {\n    if (!options.initiatorTypes.includes('xmlhttprequest')) {\n        return () => {\n            //\n        }\n    }\n    const recordRequestHeaders = shouldRecordHeaders('request', options.recordHeaders)\n    const recordResponseHeaders = shouldRecordHeaders('response', options.recordHeaders)\n\n    const restorePatch = patch(\n        win.XMLHttpRequest.prototype,\n        'open',\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        (originalOpen: typeof XMLHttpRequest.prototype.open) => {\n            return function (\n                method: string,\n                url: string | URL,\n                async = true,\n                username?: string | null,\n                password?: string | null\n            ) {\n                // because this function is returned in its actual context `this` _is_ an XMLHttpRequest\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                const xhr = this as XMLHttpRequest\n\n                // check IE earlier than this, we only initialize if Request is present\n                // eslint-disable-next-line compat/compat\n                const req = new Request(url)\n                const networkRequest: Partial<CapturedNetworkRequest> = {}\n                let after: number | undefined\n                let before: number | undefined\n\n                const requestHeaders: Headers = {}\n                const originalSetRequestHeader = xhr.setRequestHeader.bind(xhr)\n                xhr.setRequestHeader = (header: string, value: string) => {\n                    requestHeaders[header] = value\n                    return originalSetRequestHeader(header, value)\n                }\n                if (recordRequestHeaders) {\n                    networkRequest.requestHeaders = requestHeaders\n                }\n\n                const originalSend = xhr.send.bind(xhr)\n                xhr.send = (body) => {\n                    if (\n                        shouldRecordBody({\n                            type: 'request',\n                            headers: requestHeaders,\n                            url,\n                            recordBody: options.recordBody,\n                        })\n                    ) {\n                        networkRequest.requestBody = _tryReadXHRBody({ body, options, url })\n                    }\n                    after = win.performance.now()\n                    return originalSend(body)\n                }\n\n                xhr.addEventListener('readystatechange', () => {\n                    if (xhr.readyState !== xhr.DONE) {\n                        return\n                    }\n                    before = win.performance.now()\n                    const responseHeaders: Headers = {}\n                    const rawHeaders = xhr.getAllResponseHeaders()\n                    const headers = rawHeaders.trim().split(/[\\r\\n]+/)\n                    headers.forEach((line) => {\n                        const parts = line.split(': ')\n                        const header = parts.shift()\n                        const value = parts.join(': ')\n                        if (header) {\n                            responseHeaders[header] = value\n                        }\n                    })\n                    if (recordResponseHeaders) {\n                        networkRequest.responseHeaders = responseHeaders\n                    }\n                    if (\n                        shouldRecordBody({\n                            type: 'response',\n                            headers: responseHeaders,\n                            url,\n                            recordBody: options.recordBody,\n                        })\n                    ) {\n                        networkRequest.responseBody = _tryReadXHRBody({ body: xhr.response, options, url })\n                    }\n                    getRequestPerformanceEntry(win, 'xmlhttprequest', req.url, after, before)\n                        .then((entry) => {\n                            if (isNull(entry)) {\n                                return\n                            }\n                            const requests = prepareRequest(entry, req.method, xhr?.status, networkRequest)\n                            cb({ requests })\n                        })\n                        .catch(() => {\n                            //\n                        })\n                })\n                originalOpen.call(xhr, method, url, async, username, password)\n            }\n        }\n    )\n    return () => {\n        restorePatch()\n    }\n}\n\n/**\n *  Check if this PerformanceEntry is either a PerformanceResourceTiming or a PerformanceNavigationTiming\n *  NB PerformanceNavigationTiming extends PerformanceResourceTiming\n *  Here we don't care which interface it implements as both expose `serverTimings`\n */\nconst exposesServerTiming = (event: PerformanceEntry): event is PerformanceResourceTiming =>\n    event.entryType === 'navigation' || event.entryType === 'resource'\n\nfunction prepareRequest(\n    entry: PerformanceResourceTiming,\n    method: string | undefined,\n    status: number | undefined,\n    networkRequest: Partial<CapturedNetworkRequest>,\n    isInitial?: boolean\n): CapturedNetworkRequest[] {\n    // kudos to sentry javascript sdk for excellent background on why to use Date.now() here\n    // https://github.com/getsentry/sentry-javascript/blob/e856e40b6e71a73252e788cd42b5260f81c9c88e/packages/utils/src/time.ts#L70\n    // can't start observer if performance.now() is not available\n    // eslint-disable-next-line compat/compat\n    const timeOrigin = Math.floor(Date.now() - performance.now())\n    // clickhouse can't ingest timestamps that are floats\n    // (in this case representing fractions of a millisecond we don't care about anyway)\n    const timestamp = Math.floor(timeOrigin + entry.startTime)\n\n    const requests: CapturedNetworkRequest[] = [\n        {\n            ...entry.toJSON(),\n            startTime: Math.round(entry.startTime),\n            endTime: Math.round(entry.responseEnd),\n            timeOrigin,\n            timestamp,\n            method: method,\n            initiatorType: entry.initiatorType as InitiatorType,\n            status,\n            requestHeaders: networkRequest.requestHeaders,\n            requestBody: networkRequest.requestBody,\n            responseHeaders: networkRequest.responseHeaders,\n            responseBody: networkRequest.responseBody,\n            isInitial,\n        },\n    ]\n\n    if (exposesServerTiming(entry)) {\n        for (const timing of entry.serverTiming || []) {\n            requests.push({\n                timeOrigin,\n                timestamp,\n                startTime: Math.round(entry.startTime),\n                name: timing.name,\n                duration: timing.duration,\n                // the spec has a closed list of possible types\n                // https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType\n                // but, we need to know this was a server timing so that we know to\n                // match it to the appropriate navigation or resource timing\n                // that matching will have to be on timestamp and $current_url\n                entryType: 'serverTiming',\n            })\n        }\n    }\n\n    return requests\n}\n\nconst contentTypePrefixDenyList = ['video/', 'audio/']\n\nfunction _checkForCannotReadResponseBody({\n    r,\n    options,\n    url,\n}: {\n    r: Response\n    options: NetworkRecordOptions\n    url: string | URL | RequestInfo\n}): string | null {\n    if (r.headers.get('Transfer-Encoding') === 'chunked') {\n        return 'Chunked Transfer-Encoding is not supported'\n    }\n\n    // `get` and `has` are case-insensitive\n    // but return the header value with the casing that was supplied\n    const contentType = r.headers.get('Content-Type')?.toLowerCase()\n    const contentTypeIsDenied = contentTypePrefixDenyList.some((prefix) => contentType?.startsWith(prefix))\n    if (contentType && contentTypeIsDenied) {\n        return `Content-Type ${contentType} is not supported`\n    }\n\n    const { hostname, isHostDenied } = isHostOnDenyList(url, options)\n    if (isHostDenied) {\n        return hostname + ' is in deny list'\n    }\n\n    return null\n}\n\nfunction _tryReadBody(r: Request | Response): Promise<string> {\n    // there are now already multiple places where we're using Promise...\n    // eslint-disable-next-line compat/compat\n    return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => resolve('[SessionReplay] Timeout while trying to read body'), 500)\n        r.clone()\n            .text()\n            .then(\n                (txt) => resolve(txt),\n                (reason) => reject(reason)\n            )\n            .finally(() => clearTimeout(timeout))\n    })\n}\n\nasync function _tryReadRequestBody({\n    r,\n    options,\n    url,\n}: {\n    r: Request\n    options: NetworkRecordOptions\n    url: string | URL | RequestInfo\n}): Promise<string> {\n    const { hostname, isHostDenied } = isHostOnDenyList(url, options)\n    if (isHostDenied) {\n        return Promise.resolve(hostname + ' is in deny list')\n    }\n\n    return _tryReadBody(r)\n}\n\nasync function _tryReadResponseBody({\n    r,\n    options,\n    url,\n}: {\n    r: Response\n    options: NetworkRecordOptions\n    url: string | URL | RequestInfo\n}): Promise<string> {\n    const cannotReadBodyReason: string | null = _checkForCannotReadResponseBody({ r, options, url })\n    if (!isNull(cannotReadBodyReason)) {\n        return Promise.resolve(cannotReadBodyReason)\n    }\n\n    return _tryReadBody(r)\n}\n\nfunction initFetchObserver(\n    cb: networkCallback,\n    win: IWindow,\n    options: Required<NetworkRecordOptions>\n): listenerHandler {\n    if (!options.initiatorTypes.includes('fetch')) {\n        return () => {\n            //\n        }\n    }\n    const recordRequestHeaders = shouldRecordHeaders('request', options.recordHeaders)\n    const recordResponseHeaders = shouldRecordHeaders('response', options.recordHeaders)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const restorePatch = patch(win, 'fetch', (originalFetch: typeof fetch) => {\n        return async function (url: URL | RequestInfo, init?: RequestInit | undefined) {\n            // check IE earlier than this, we only initialize if Request is present\n            // eslint-disable-next-line compat/compat\n            const req = new Request(url, init)\n            let res: Response | undefined\n            const networkRequest: Partial<CapturedNetworkRequest> = {}\n            let after: number | undefined\n            let before: number | undefined\n            try {\n                const requestHeaders: Headers = {}\n                req.headers.forEach((value, header) => {\n                    requestHeaders[header] = value\n                })\n                if (recordRequestHeaders) {\n                    networkRequest.requestHeaders = requestHeaders\n                }\n                if (\n                    shouldRecordBody({\n                        type: 'request',\n                        headers: requestHeaders,\n                        url,\n                        recordBody: options.recordBody,\n                    })\n                ) {\n                    networkRequest.requestBody = await _tryReadRequestBody({ r: req, options, url })\n                }\n\n                after = win.performance.now()\n                res = await originalFetch(req)\n                before = win.performance.now()\n\n                const responseHeaders: Headers = {}\n                res.headers.forEach((value, header) => {\n                    responseHeaders[header] = value\n                })\n                if (recordResponseHeaders) {\n                    networkRequest.responseHeaders = responseHeaders\n                }\n                if (\n                    shouldRecordBody({\n                        type: 'response',\n                        headers: responseHeaders,\n                        url,\n                        recordBody: options.recordBody,\n                    })\n                ) {\n                    networkRequest.responseBody = await _tryReadResponseBody({ r: res, options, url })\n                }\n\n                return res\n            } finally {\n                getRequestPerformanceEntry(win, 'fetch', req.url, after, before)\n                    .then((entry) => {\n                        if (isNull(entry)) {\n                            return\n                        }\n                        const requests = prepareRequest(entry, req.method, res?.status, networkRequest)\n                        cb({ requests })\n                    })\n                    .catch(() => {\n                        //\n                    })\n            }\n        }\n    })\n    return () => {\n        restorePatch()\n    }\n}\n\nlet initialisedHandler: listenerHandler | null = null\n\nfunction initNetworkObserver(\n    callback: networkCallback,\n    win: IWindow, // top window or in an iframe\n    options: NetworkRecordOptions\n): listenerHandler {\n    if (!('performance' in win)) {\n        return () => {\n            //\n        }\n    }\n\n    if (initialisedHandler) {\n        logger.warn('Network observer already initialised, doing nothing')\n        return () => {\n            // the first caller should already have this handler and will be responsible for teardown\n        }\n    }\n\n    const networkOptions = (\n        options ? Object.assign({}, defaultNetworkOptions, options) : defaultNetworkOptions\n    ) as Required<NetworkRecordOptions>\n\n    const cb: networkCallback = (data) => {\n        const requests: CapturedNetworkRequest[] = []\n        data.requests.forEach((request) => {\n            const maskedRequest = networkOptions.maskRequestFn(request)\n            if (maskedRequest) {\n                requests.push(maskedRequest)\n            }\n        })\n\n        if (requests.length > 0) {\n            callback({ ...data, requests })\n        }\n    }\n    const performanceObserver = initPerformanceObserver(cb, win, networkOptions)\n\n    // only wrap fetch and xhr if headers or body are being recorded\n    let xhrObserver: listenerHandler = () => {}\n    let fetchObserver: listenerHandler = () => {}\n    if (networkOptions.recordHeaders || networkOptions.recordBody) {\n        xhrObserver = initXhrObserver(cb, win, networkOptions)\n        fetchObserver = initFetchObserver(cb, win, networkOptions)\n    }\n\n    initialisedHandler = () => {\n        performanceObserver()\n        xhrObserver()\n        fetchObserver()\n    }\n    return initialisedHandler\n}\n\n// use the plugin name so that when this functionality is adopted into rrweb\n// we can remove this plugin and use the core functionality with the same data\nexport const NETWORK_PLUGIN_NAME = 'rrweb/network@1'\n\n// TODO how should this be typed?\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nexport const getRecordNetworkPlugin: (options?: NetworkRecordOptions) => RecordPlugin = (options) => {\n    return {\n        name: NETWORK_PLUGIN_NAME,\n        observer: initNetworkObserver,\n        options: options,\n    }\n}\n\n// rrweb/networ@1 ends\n\nif (window) {\n    ;(window as any).rrweb = { record: rrwebRecord, version: 'v2', rrwebVersion: version }\n    ;(window as any).rrwebConsoleRecord = { getRecordConsolePlugin }\n    ;(window as any).getRecordNetworkPlugin = getRecordNetworkPlugin\n}\n\nexport default rrwebRecord\n"]}